<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ABROX AI — Elite Login (Hologram Candles) — Damon Canvas</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#030313;
    --panel-bg: rgba(6,8,20,0.38);
    --glass-edge: rgba(255,255,255,0.06);
    --accent1:#00eaff;
    --accent2:#b300ff;
    --muted: rgba(255,255,255,0.65);
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:"Poppins",system-ui,Arial;color:#fff;overflow:hidden}
  #scene { position:fixed; inset:0; z-index:0; }
  canvas { width:100%; height:100%; display:block; }

  /* retain your UI on top */
  .brand { position: absolute; left:28px; top:22px; z-index:12; display:flex; gap:12px; align-items:center; }
  .brand .logo { width:46px; height:46px; border-radius:10px; background: linear-gradient(145deg,var(--accent1), var(--accent2)); box-shadow:0 6px 20px rgba(179,0,255,0.12), inset 0 -6px 18px rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; font-weight:900; color:#051025; }
  .brand .txt { font-size:15px; color:var(--muted); }

  main.panel {
    position: absolute; z-index:14; left:50%; top:50%; transform:translate(-50%,-50%);
    width:100%; max-width:520px; padding:34px; border-radius:20px; background:var(--panel-bg);
    border:1px solid var(--glass-edge); backdrop-filter: blur(12px) saturate(1.2);
    box-shadow:0 10px 60px rgba(2,8,20,0.6), 0 0 45px rgba(0,230,255,0.04), 0 0 90px rgba(179,0,255,0.04);
    text-align:center; transition: transform .38s, box-shadow .28s; will-change: transform;
  }
  .title{ font-size:28px; font-weight:800; margin:0 0 10px 0; background: linear-gradient(90deg,var(--accent1), #65e4ff, var(--accent2)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
  .sub{ font-size:13px; color:rgba(255,255,255,0.66); margin-bottom:18px; }
  .field{ width:100%; padding:14px 16px; border-radius:12px; border:1px solid rgba(255,255,255,0.04); background: rgba(8,10,20,0.48); color:#e6fbff; font-size:15px; margin-top:12px; box-sizing:border-box; }
  .btn{ width:100%; margin-top:18px; padding:13px; border-radius:12px; border:none; font-weight:800; font-size:16px; cursor:pointer; color:#041224; background: linear-gradient(90deg,#bef7ff,#ffd6ff); box-shadow: 0 12px 40px rgba(179,0,255,0.12); }
  .hint{ margin-top:12px; font-size:12px; color:rgba(255,255,255,0.46); }

  /* optional small message */
  .no-canvas { position: absolute; z-index:30; left:50%; top:12%; transform:translateX(-50%); padding:8px 12px; border-radius:10px; background:rgba(0,0,0,0.45); color:#ffd; font-size:13px; border:1px solid rgba(255,255,255,0.04); display:none; }

  @media (max-width:520px){ main.panel{ width:92%; padding:20px; border-radius:14px; } .title{ font-size:20px; } }
</style>
</head>
<body>

<div id="scene" aria-hidden="true">
  <canvas id="candlesCanvas"></canvas>
</div>

<div class="brand" style="z-index:14;">
  <div class="logo">A</div>
  <div class="txt">ABROX AI <div style="font-size:11px;color:rgba(255,255,255,0.44);font-weight:600">Elite Holograph</div></div>
</div>

<main class="panel" id="uiPanel" role="main" aria-label="Login panel">
  <h1 class="title">Abrox AI Login</h1>
  <div class="sub">Enter the UID and dashboard password assigned to your subscription.</div>

  <input id="uidInput" class="field" type="text" placeholder="Enter your UID" />
  <input id="passInput" class="field" type="password" placeholder="Dashboard Password" />

  <button class="btn" id="loginBtn">LOGIN</button>
  <div class="hint">Secure • Encrypted • Neon-grade UX</div>
</main>

<div class="no-canvas" id="noCanvas">Canvas not supported — loading a simple fallback.</div>

<script>
/*
  High-density animated candle wall (Canvas)
  - Auto-detects performance and adjusts candleCount
  - Uses layered draws for glow (fast)
  - Parallax via pointer/gyro
  - Smooth flicker using per-candle noise seeds
*/

(() => {
  const canvas = document.getElementById('candlesCanvas');
  const noCanvas = document.getElementById('noCanvas');
  if (!canvas || !canvas.getContext) {
    noCanvas.style.display = 'block';
    return;
  }
  const ctx = canvas.getContext('2d', { alpha: true });

  // Resize to device pixels
  function resize() {
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    canvas.width = Math.round(window.innerWidth * dpr);
    canvas.height = Math.round(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // Performance tuning: fewer candles on low-end / mobile
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);
  const devicePerf = (() => {
    // crude perf estimation: smaller screens -> lower
    const shortSide = Math.min(window.innerWidth, window.innerHeight);
    if (isMobile) return 'low';
    if (shortSide < 700) return 'medium';
    return 'high';
  })();

  // Candle density (columns X rows)
  let cols = 44, rows = 12; // default (dense)
  if (devicePerf === 'medium') { cols = 34; rows = 10; }
  if (devicePerf === 'low') { cols = 20; rows = 8; }

  // allow user override by URL param ?density=low|med|high
  try {
    const params = new URLSearchParams(location.search);
    const d = params.get('density');
    if (d === 'low') { cols = 20; rows = 8; }
    if (d === 'med' || d === 'medium') { cols = 34; rows = 10; }
    if (d === 'high') { cols = 64; rows = 16; }
  } catch (e) {}

  // compute total candles & spacing
  const total = cols * rows;
  const padding = 40;
  const areaW = window.innerWidth - padding*2;
  const areaH = window.innerHeight - padding*2;

  // store candle objects
  const candles = [];
  const now = performance.now();
  for (let rz = 0; rz < rows; rz++) {
    for (let cx = 0; cx < cols; cx++) {
      const jitterX = (Math.random()-0.5) * 0.6; // small random offset
      const jitterZ = (Math.random()-0.5) * 0.6;
      const x = padding + (cx + 0.5 + jitterX) * (areaW / cols);
      const z = padding + (rz + 0.5 + jitterZ) * (areaH / rows);

      const baseHeight = (areaH * (0.18 + Math.random()*0.42)) * (1 - rz / (rows*1.15)); // front rows taller
      const width = Math.max(2.2, (areaW / cols) * (0.18 + Math.random()*0.22)); // bar width in px
      const hue = 195 + Math.random() * 40; // bluish-cyan range
      const seed = Math.random() * 1000;

      candles.push({
        x, z,
        baseHeight,
        width,
        hue,
        seed,
        flickOff: Math.random()*0.6 // controls min flicker
      });
    }
  }

  // pointer parallax & device orientation
  let pointerX = 0, pointerY = 0;
  window.addEventListener('mousemove', (e) => {
    pointerX = (e.clientX / window.innerWidth) * 2 - 1;
    pointerY = (e.clientY / window.innerHeight) * 2 - 1;
  }, { passive: true });

  if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', (ev) => {
      if (ev.gamma !== null) {
        pointerX = Math.max(-1, Math.min(1, ev.gamma / 45));
        pointerY = Math.max(-1, Math.min(1, (ev.beta/90) - 0.5));
      }
    }, true);
  }

  // helper: perlin-ish noise (fast)
  function fastNoise(t) {
    return Math.sin(t)*0.5 + Math.sin(t*1.7)*0.25 + Math.sin(t*2.9)*0.15;
  }

  // draw loop
  let last = performance.now();
  function draw() {
    const t = (performance.now() - now) * 0.001;
    const dt = Math.min(0.05, (performance.now() - last)/1000);
    last = performance.now();

    // fade background slightly to keep depth (doesn't clear to pure black)
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Create base subtle radial vignette
    const g = ctx.createLinearGradient(0,0,0,window.innerHeight);
    g.addColorStop(0, 'rgba(2,6,20,0.12)');
    g.addColorStop(1, 'rgba(0,0,0,0.45)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,window.innerWidth, window.innerHeight);

    // parallax offset for camera feel
    const parX = pointerX * 18;
    const parY = pointerY * 12;

    // draw candles in back-to-front order (rows -> depth)
    for (let r = rows - 1; r >= 0; r--) {
      for (let c = 0; c < cols; c++) {
        const idx = r * cols + c;
        const cd = candles[idx];

        // flicker calculation
        const flick1 = Math.sin(t*2.0 + cd.seed) * 0.45;
        const flick2 = fastNoise(t*1.4 + cd.seed*0.7) * 0.35;
        const flick = (flick1 + flick2) * (0.6 + cd.flickOff * 0.8);

        // current height & glow intensity
        const h = Math.max(6, cd.baseHeight + flick * 18 + Math.sin(t*0.6 + cd.seed)*6);
        const glow = 0.6 + Math.max(0, flick) * 1.4;

        // horizontal position with slight drift
        const x = cd.x + parX * ( (c/cols) - 0.5) * 0.7 + Math.sin(t*0.15 + cd.seed*0.3) * 2;
        const y = cd.z + parY * ( (r/rows) - 0.5) * 0.6;

        // draw glow layer (soft, wide)
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.translate(x, y);

        // outer glow
        const outerRadius = Math.max(18, h * 0.65) * (0.9 + r/rows*0.6);
        ctx.beginPath();
        const grad = ctx.createRadialGradient(0, -h/2, 0, 0, -h/2, outerRadius);
        grad.addColorStop(0, `rgba(70,220,255,${0.06 * glow})`);
        grad.addColorStop(0.25, `rgba(70,220,255,${0.03 * glow})`);
        grad.addColorStop(1, `rgba(7,12,30,0)`);
        ctx.fillStyle = grad;
        ctx.fillRect(-outerRadius, -h - outerRadius, outerRadius*2, outerRadius*2);

        // mid glow subtle purple tint for depth
        const grad2 = ctx.createRadialGradient(0, -h/2, 0, 0, -h/2, outerRadius*0.6);
        grad2.addColorStop(0, `rgba(179,0,255,${0.02 * (1 - r/rows) * glow})`);
        grad2.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad2;
        ctx.fillRect(-outerRadius, -h - outerRadius, outerRadius*2, outerRadius*2);

        // candle body (slightly translucent)
        const bodyWidth = cd.width * (0.9 + (r/rows)*0.25);
        const bodyX = -bodyWidth/2;
        const bodyY = -h;

        // body gradient vertical (darker base, brighter top)
        const bodyGrad = ctx.createLinearGradient(0, bodyY, 0, bodyY + h);
        bodyGrad.addColorStop(0, `rgba(0,18,30,0.9)`);
        bodyGrad.addColorStop(0.6, `rgba(12,40,66,0.7)`);
        bodyGrad.addColorStop(1, `rgba(4,10,18,0.42)`);
        ctx.fillStyle = bodyGrad;
        ctx.fillRect(bodyX, bodyY, bodyWidth, h);

        // inner highlight (thin)
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = `rgba(50,180,255,${0.06 + 0.04*glow})`;
        ctx.fillRect(bodyX + bodyWidth*0.12, bodyY + h*0.06, bodyWidth*0.12, h*0.88);

        // top cap — small bright rectangle that pulses
        const capH = Math.max(4, Math.min(18, h * 0.06 + Math.abs(flick)*6));
        const capW = bodyWidth * (1.08 + Math.sin(t*4 + cd.seed)*0.03);
        ctx.globalCompositeOperation = 'lighter';
        const capGrad = ctx.createLinearGradient(0, -h - capH, 0, -h);
        capGrad.addColorStop(0, `rgba(130,255,255,${0.75 * glow})`);
        capGrad.addColorStop(0.6, `rgba(110,220,255,${0.25 * glow})`);
        capGrad.addColorStop(1, `rgba(120,180,255,${0.02})`);
        ctx.fillStyle = capGrad;
        ctx.fillRect(-capW/2, -h - capH, capW, capH);

        // tiny rim glow & spark (very small)
        if (Math.random() < 0.008 + Math.abs(flick)*0.012) {
          ctx.beginPath();
          ctx.fillStyle = `rgba(255,255,255,${0.5 * glow})`;
          ctx.arc((Math.random()-0.5)*capW*0.3, -h - capH*0.5, 1.2 + Math.random()*1.6, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.restore();
      }
    }

    // top-most subtle noise overlay for filmic effect
    ctx.save();
    ctx.globalAlpha = 0.035;
    for (let i = 0; i < 60; i++) {
      ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.02})`;
      ctx.fillRect(Math.random()*window.innerWidth, Math.random()*window.innerHeight, 1, 1);
    }
    ctx.restore();

    requestAnimationFrame(draw);
  }

  // start
  draw();

  // expose a method to increase/decrease density at runtime (optional)
  window.__ABROX_Candles = {
    setDensity: (level) => {
      if (level === 'low') { cols = 20; rows = 8; }
      if (level === 'med') { cols = 34; rows = 10; }
      if (level === 'high') { cols = 64; rows = 16; }
      // rebuild candles quickly (simple reload)
      // (For brevity, a page reload is easiest)
      location.search = '?density=' + level;
    }
  };
})();
</script>

<!-- keep your original verify() logic (unchanged) -->
<script>
function togglePass(){ const p = document.getElementById("passInput"); p.type = p.type === "password" ? "text" : "password"; }
function showAlert(m){ alert(m); }
async function verify(){
  const uid = uidInput.value.trim();
  const pass = passInput.value.trim();
  if(!uid || !pass) return showAlert("Enter UID and Password");
  try{
    const s = await fetch("https://raw.githubusercontent.com/AbroxAI/abrox-web/main/subscribers.json",{cache:"no-store"});
    if(!s.ok) return showAlert("Failed to load subscribers.");
    const subs = await s.json();
    if(!subs[uid]) return showAlert("UID not found.");
    const e = await fetch("https://raw.githubusercontent.com/AbroxAI/abrox-web/main/.env",{cache:"no-store"});
    if(!e.ok) return showAlert("Failed to load config.");
    const envText = await e.text();
    const m = envText.match(/DASHBOARD_PASSWORD=(.*)/);
    if(!m) return showAlert("Password config missing.");
    const correct = m[1].trim();
    if(pass !== correct) return showAlert("Incorrect password.");
    window.location.href = "dashboard.html?uid="+encodeURIComponent(uid);
  }catch(err){
    console.error(err);
    showAlert("Connection error.");
  }
}
document.getElementById('loginBtn').addEventListener('click', verify);
</script>
</body>
</html>
