<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ABROX AI — Elite Login (Hologram Candles) — Damon Edition</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#030313;
    --panel-bg: rgba(6,8,20,0.38);
    --glass-edge: rgba(255,255,255,0.06);
    --accent1:#00eaff;
    --accent2:#b300ff;
    --muted: rgba(255,255,255,0.65);
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:"Poppins",system-ui,Arial;color:#fff;overflow:hidden}
  #app{position:fixed;inset:0;display:block;}

/* Canvas sits behind everything */
  canvas{display:block; width:100%; height:100%; position: absolute; top:0; left:0; z-index:0;}

/* Top-left brand */
  .brand {
    position: absolute; left:28px; top:22px; z-index:9; font-weight:800; letter-spacing:0.6px;
    display:flex; gap:12px; align-items:center;
  }
  .brand .logo {
    width:46px; height:46px; border-radius:10px;
    background: linear-gradient(145deg,var(--accent1), var(--accent2));
    box-shadow:0 6px 20px rgba(179,0,255,0.12), inset 0 -6px 18px rgba(0,0,0,0.35);
    display:flex; align-items:center; justify-content:center; font-weight:900; color:#051025;
    transform:translateZ(20px);
  }
  .brand .txt {font-size:15px; color:var(--muted);}

/* Panel centered */
  .panel {
    position: absolute; z-index:12; left:50%; top:50%;
    transform: translate(-50%,-50%);
    width:100%; max-width:520px; padding:34px; border-radius:20px;
    background:var(--panel-bg);
    border:1px solid var(--glass-edge);
    backdrop-filter: blur(12px) saturate(1.2);
    box-shadow:
      0 10px 60px rgba(2,8,20,0.6),
      0 0 45px rgba(0,230,255,0.04),
      0 0 90px rgba(179,0,255,0.04);
    text-align:center;
    transition: transform .38s cubic-bezier(.2,.9,.2,1), box-shadow .28s;
    will-change: transform;
  }

  .title{
    font-size:28px; font-weight:800; margin:0 0 10px 0;
    background: linear-gradient(90deg,var(--accent1), #65e4ff, var(--accent2));
    -webkit-background-clip:text; -webkit-text-fill-color:transparent;
  }
  .sub { font-size:13px; color:rgba(255,255,255,0.66); margin-bottom:18px; }

  .field { width:100%; padding:14px 16px; border-radius:12px; border:1px solid rgba(255,255,255,0.04);
    background: rgba(8,10,20,0.48); color:#e6fbff; font-size:15px; box-sizing:border-box; margin-top:12px;
    transition: box-shadow .18s, border .18s, transform .12s;
  }
  .field:focus { outline:none; border-color: rgba(0,230,255,0.18); box-shadow: 0 6px 28px rgba(0,230,255,0.03) inset; transform:translateY(-1px); }

  .row { display:flex; gap:10px; margin-top:14px; }
  .btn {
    width:100%; margin-top:18px; padding:13px; border-radius:12px; border:none; font-weight:800; font-size:16px;
    cursor:pointer; color:#041224;
    background: linear-gradient(90deg,#bef7ff,#ffd6ff);
    box-shadow: 0 12px 40px rgba(179,0,255,0.12), 0 6px 18px rgba(0,0,0,0.4);
    transition: transform .14s ease, box-shadow .14s ease;
  }
  .btn:active{ transform: translateY(2px) scale(.998); }

  /* small micro-neon under text */
  .panel::after{
    content:""; position:absolute; left:6%; right:6%; bottom:-28px; height:6px; border-radius:999px;
    background: linear-gradient(90deg, rgba(0,234,255,0.08), rgba(179,0,255,0.08));
    filter: blur(12px);
  }

  .hint { margin-top:12px; font-size:12px; color:rgba(255,255,255,0.46); }

/* mobile */
  @media (max-width:520px){
    .panel{ width:92%; padding:20px; border-radius:14px; }
    .title{ font-size:20px; }
  }

  /* small performance warning */
  .no-webgl {
    position: absolute; z-index:20; left:50%; top:20%; transform:translateX(-50%); background:rgba(0,0,0,0.45);
    padding:8px 14px; border-radius:10px; font-size:13px; color:#ffe; border:1px solid rgba(255,255,255,0.04);
  }
</style>
</head>

<body>
<div id="app" aria-hidden="false"></div>

<div class="brand" style="z-index:20;">
  <div class="logo">A</div>
  <div class="txt">ABROX AI <div style="font-size:11px; color:rgba(255,255,255,0.44); font-weight:600">Elite Holograph</div></div>
</div>

<main class="panel" id="uiPanel" role="main" aria-label="Login panel">
  <h1 class="title">Abrox AI Login</h1>
  <div class="sub">Enter the UID and dashboard password assigned to your subscription.</div>

  <input id="uidInput" class="field" type="text" placeholder="Enter your UID" />
  <input id="passInput" class="field" type="password" placeholder="Dashboard Password" />

  <button class="btn" id="loginBtn">LOGIN</button>
  <div class="hint">Secure • Encrypted • Neon-grade UX</div>
</main>

<div id="noWebgl" class="no-webgl" style="display:none">WebGL not supported — loading lightweight fallback.</div>

<!-- Three.js + postprocessing (from CDN) -->
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/jsm/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/shaders/CopyShader.js"></script>

<script>
/* =======================================================================
   $20k Hologram Candles - Three.js scene
   - Instanced candlesticks (fast)
   - Bloom + subtle DOF-like blur (unreal bloom)
   - Particles that respond to panel
   - Panel gets a tiny parallax reflection (via screen-space light)
   - Mouse/gyro parallax
   ======================================================================= */

(() => {
  const container = document.getElementById('app');
  const uiPanel = document.getElementById('uiPanel');
  const noWebgl = document.getElementById('noWebgl');

  // Feature detect WebGL
  function webglAvailable() {
    try {
      const canvas = document.createElement('canvas');
      return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    } catch (e) { return false; }
  }

  if (!webglAvailable()) {
    noWebgl.style.display = 'block';
    // Add nice static CSS fallback here (simple gradient + CSS candles)
    container.innerHTML = '';
    return;
  }

  // Basic three.js setup
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x020416, 0.0008);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.outputEncoding = THREE.sRGBEncoding;
  container.appendChild(renderer.domElement);

  // camera
  const camera = new THREE.PerspectiveCamera(36, window.innerWidth / window.innerHeight, 0.1, 2000);
  camera.position.set(0, 14, 60);

  // subtle ambient + directional
  const amb = new THREE.AmbientLight(0x99dfff, 0.45);
  scene.add(amb);
  const dir = new THREE.DirectionalLight(0x99e6ff, 0.85);
  dir.position.set(-10, 20, 10);
  scene.add(dir);

  // group for candles
  const candlesGroup = new THREE.Group();
  scene.add(candlesGroup);

  // Instanced candlesticks - geometry: thin box with top "wick cap"
  const candleCountX = 11;
  const candleCountZ = 6;
  const totalCandles = candleCountX * candleCountZ;
  const candleGeom = new THREE.BoxGeometry(1,1,1);
  const candleMat = new THREE.MeshStandardMaterial({
    color: 0x053b66,
    emissive: 0x001a30,
    metalness: 0.15,
    roughness: 0.35,
    transparent: true,
    opacity: 0.95
  });

  // Instanced mesh
  const inst = new THREE.InstancedMesh(candleGeom, candleMat, totalCandles);
  inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  inst.castShadow = false;
  inst.receiveShadow = false;
  candlesGroup.add(inst);

  // extra small emissive cap geometry for the top of candlestick (glow)
  const capGeom = new THREE.BoxGeometry(1.1,0.6,1.1);
  const capMat = new THREE.MeshStandardMaterial({
    color: 0x0fdfff,
    emissive: 0x0fdfff,
    emissiveIntensity: 0.8,
    metalness: 0.8,
    roughness: 0.2,
    transparent: true
  });
  const caps = new THREE.InstancedMesh(capGeom, capMat, totalCandles);
  caps.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  candlesGroup.add(caps);

  // randomize and set initial matrices & metadata
  const dummy = new THREE.Object3D();
  const dummyCap = new THREE.Object3D();
  const candleData = []; // store each candle's baseline params
  let idx = 0;
  for (let i=0;i<candleCountZ;i++){
    for (let j=0;j<candleCountX;j++){
      const x = (j - (candleCountX-1)/2) * 5.8 + (Math.random()-0.5) * 0.5;
      const z = (i - (candleCountZ-1)/2) * -8 + (Math.random()-0.5) * 0.8;
      const baseHeight = 8 + Math.random()*20; // base height
      const width = 1 + Math.random()*1.4;
      const rot = (Math.random()-0.5) * 0.08;
      dummy.position.set(x, baseHeight/2 - 2, z);
      dummy.scale.set(width, baseHeight, 1.2);
      dummy.rotation.y = rot;
      dummy.updateMatrix();
      inst.setMatrixAt(idx, dummy.matrix);

      // cap slightly above top
      dummyCap.position.set(x, baseHeight - 1.2 - 2, z);
      dummyCap.scale.set(width*1.06, 0.6, 1.2);
      dummyCap.updateMatrix();
      caps.setMatrixAt(idx, dummyCap.matrix);

      candleData.push({
        x,z, baseHeight, width, rot,
        flickerSeed: Math.random()*1000,
        heightOffset: (Math.random()-0.5) * 2.4
      });
      idx++;
    }
  }
  inst.instanceMatrix.needsUpdate = true;
  caps.instanceMatrix.needsUpdate = true;

  // particle field (small points)
  const particleCount = 800;
  const particleGeo = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const speeds = new Float32Array(particleCount);
  for (let i=0;i<particleCount;i++){
    positions[i*3+0] = (Math.random()-0.5) * 220;
    positions[i*3+1] = Math.random() * 140 - 10;
    positions[i*3+2] = (Math.random()-0.5) * 280;
    speeds[i] = 0.2 + Math.random()*0.9;
  }
  particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  particleGeo.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));
  const particleMat = new THREE.PointsMaterial({
    size: 1.6,
    map: null,
    depthWrite: false,
    transparent: true,
    opacity: 0.9,
    color: 0x6ad8ff
  });
  const particles = new THREE.Points(particleGeo, particleMat);
  scene.add(particles);

  // subtle ground gradient plane to reflect mood
  const groundGeo = new THREE.PlaneGeometry(1200, 1200);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x010612, metalness: 0.1, roughness: 0.9, emissive: 0x000000 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -22;
  scene.add(ground);

  // postprocessing - RenderPass + UnrealBloom
  const composer = new THREE.EffectComposer(renderer);
  const renderPass = new THREE.RenderPass(scene, camera);
  composer.addPass(renderPass);

  const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.8, 0.1);
  bloomPass.threshold = 0.12;
  bloomPass.strength = 0.9;
  bloomPass.radius = 0.6;
  composer.addPass(bloomPass);

  // small copy pass to screen
  const copyPass = new THREE.ShaderPass(THREE.CopyShader);
  copyPass.renderToScreen = true;
  composer.addPass(copyPass);

  // handle resize
  window.addEventListener('resize', onWindowResize);
  function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  }

  // parallax controls: mouse + gyro
  let pointerX = 0, pointerY = 0;
  window.addEventListener('mousemove', (e)=> {
    pointerX = (e.clientX / window.innerWidth) * 2 - 1;
    pointerY = (e.clientY / window.innerHeight) * 2 - 1;
  });

  // mobile orientation
  if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', (ev) => {
      if (ev.gamma !== null) {
        pointerX = THREE.MathUtils.clamp(ev.gamma / 45, -1, 1);
        pointerY = THREE.MathUtils.clamp(ev.beta / 90 - 0.5, -1, 1);
      }
    }, true);
  }

  // reactive panel reflection trick: convert panel screen rect to world and apply small light
  const panelRect = () => uiPanel.getBoundingClientRect();

  // keep time
  let timeStart = performance.now();

  function animate() {
    const t = (performance.now() - timeStart) * 0.001;

    // camera subtle orbit + pointer-parallax
    const targetX = pointerX * 8;
    const targetY = pointerY * 6;
    camera.position.x += (targetX - camera.position.x) * 0.05;
    camera.position.y += (targetY + 10 - camera.position.y) * 0.05;
    camera.lookAt(0, 6, 0);

    // animate instanced candles: flicker height and cap emissive intensity
    const matrix = new THREE.Matrix4();
    const capMatrix = new THREE.Matrix4();
    for (let i=0;i<totalCandles;i++){
      const cd = candleData[i];
      const flick = Math.sin((t*1.6 + cd.flickerSeed) * (0.8 + (cd.width%1))) * 0.6 + Math.sin((t*3.2 + cd.flickerSeed*0.5) * 0.14) * 0.35;
      const noise = Math.sin((t*0.7 + cd.flickerSeed*0.33)) * 0.2;
      const h = cd.baseHeight + cd.heightOffset + flick*1.8 + noise;
      const obj = dummy;
      obj.position.set(cd.x, h/2 - 2, cd.z);
      obj.rotation.y = cd.rot + Math.sin(t*0.3 + cd.flickerSeed*0.2) * 0.01;
      obj.scale.set(cd.width, h, 1.2);
      obj.updateMatrix();
      inst.setMatrixAt(i, obj.matrix);

      // cap matrix
      const cap = dummyCap;
      cap.position.set(cd.x, h - 1.15 - 2, cd.z);
      cap.scale.set(cd.width*1.06, 0.6 + Math.max(0, flick*0.1), 1.2);
      cap.updateMatrix();
      caps.setMatrixAt(i, cap.matrix);

      // animate cap emissive by updating material color / intensity slightly (cheaper: adjust instance color via material uniforms not available)
    }
    inst.instanceMatrix.needsUpdate = true;
    caps.instanceMatrix.needsUpdate = true;

    // particles drift upward; wrap around
    const pos = particleGeo.attributes.position.array;
    for (let i=0;i<particleCount;i++){
      const idx3 = i*3;
      pos[idx3+1] += 0.05 * particleGeo.attributes.aSpeed.array[i];
      pos[idx3+0] += Math.sin((t*0.14 + i) * 0.06) * 0.01;
      if (pos[idx3+1] > 120) pos[idx3+1] = -30 - Math.random()*10;
    }
    particleGeo.attributes.position.needsUpdate = true;

    // subtle bloom pulse synced to time
    bloomPass.strength = 0.7 + Math.sin(t*0.32) * 0.18;

    // slight vignette via renderer clear color blend (simulate)
    renderer.setClearColor(0x010215, 1.0);

    composer.render();
    requestAnimationFrame(animate);
  }
  animate();

  /* -------------------------
     Panel micro-interactions
     ------------------------- */
  // panel tilt on hover & subtle shine reflection based on pointer
  uiPanel.addEventListener('mousemove', (e) => {
    const r = uiPanel.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;
    const dx = (e.clientX - cx) / r.width;
    const dy = (e.clientY - cy) / r.height;
    uiPanel.style.transform = `translate(-50%,-50%) rotateX(${dy * 6}deg) rotateY(${dx * 8}deg) translateZ(8px)`;
    uiPanel.style.boxShadow = `0 18px 80px rgba(3,8,18,0.72), ${Math.abs(dx)*8}px ${Math.abs(dy)*8}px 40px rgba(179,0,255,0.06)`;
  });
  uiPanel.addEventListener('mouseleave', ()=> {
    uiPanel.style.transform = 'translate(-50%,-50%)';
    uiPanel.style.boxShadow = '';
  });

  // login micro-feedback (pulse background & small camera tilt)
  document.getElementById('loginBtn').addEventListener('click', () => {
    uiPanel.animate([
      { transform: uiPanel.style.transform || 'translate(-50%,-50%) scale(1)' },
      { transform: (uiPanel.style.transform || 'translate(-50%,-50%)') + ' scale(0.992)' },
      { transform: uiPanel.style.transform || 'translate(-50%,-50%) scale(1)' }
    ], { duration: 420, easing: 'cubic-bezier(.2,.9,.3,1)' });

    // a small cinematic camera nudge
    camera.position.z -= 3;
    setTimeout(()=> { camera.position.z += 3; }, 450);
  });

  // minimal cleanup on unload
  window.addEventListener('beforeunload', () => {
    renderer.dispose();
  });

  /* ======================
     Optional: performance mode
     ====================== */
  let lowPower = false;
  function setPerformanceMode(low) {
    if (low === lowPower) return;
    lowPower = low;
    if (lowPower) {
      bloomPass.strength = 0.45;
      renderer.setPixelRatio(1);
      particleMat.size = 1;
    } else {
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      particleMat.size = 1.6;
    }
  }
  // naive auto-detect mobile low perf
  if (/Mobi|Android/i.test(navigator.userAgent)) setPerformanceMode(true);

  /* ============================
     Accessibility / fallback
     ============================ */
  // If WebGL disabled mid-run, show fallback
  // (we already validated start)
})();
</script>

<!-- Optional: add your verify() logic below (keeps original behavior) -->
<script>
function togglePass(){ const p = document.getElementById("passInput"); p.type = p.type === "password" ? "text" : "password"; }
function showAlert(m){ alert(m); }
async function verify(){
  const uid = uidInput.value.trim();
  const pass = passInput.value.trim();
  if(!uid || !pass) return showAlert("Enter UID and Password");
  try{
    const s = await fetch("https://raw.githubusercontent.com/AbroxAI/abrox-web/main/subscribers.json",{cache:"no-store"});
    if(!s.ok) return showAlert("Failed to load subscribers.");
    const subs = await s.json();
    if(!subs[uid]) return showAlert("UID not found.");
    const e = await fetch("https://raw.githubusercontent.com/AbroxAI/abrox-web/main/.env",{cache:"no-store"});
    if(!e.ok) return showAlert("Failed to load config.");
    const envText = await e.text();
    const m = envText.match(/DASHBOARD_PASSWORD=(.*)/);
    if(!m) return showAlert("Password config missing.");
    const correct = m[1].trim();
    if(pass !== correct) return showAlert("Incorrect password.");
    window.location.href = "dashboard.html?uid="+encodeURIComponent(uid);
  }catch(err){
    console.error(err);
    showAlert("Connection error.");
  }
}
document.getElementById('loginBtn').addEventListener('click', verify);
</script>
</body>
</html>
